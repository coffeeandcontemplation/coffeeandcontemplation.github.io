<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Coffee and Contemplation &middot; A developer blog
    
  </title>

  
  <link rel="canonical" href="http://localhost:4000/page2/">
  

  <link rel="stylesheet" href="http://localhost:4000/public/css/poole.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/syntax.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/lanyon.css">
  <link rel="stylesheet" href="http://localhost:4000/public/css/tag.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" >

  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="http://localhost:4000/public/favicon.ico">

  <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost:4000/atom.xml">

  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FG8YL6SVEH"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-FG8YL6SVEH');
    </script>
  
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A blog attempting to journal my learnings</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item active" href="http://localhost:4000/">Home</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="http://localhost:4000/about/">About</a>
        
      
    
      
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="http://localhost:4000/tag/">Tags</a>
        
      
    

    <span class="sidebar-nav-item">
        <a href="/atom.xml"><i class="fa fa-rss"></i> Feed</a>
    </div>

    <!--<a class="sidebar-nav-item" href="/archive/v1.1.0.zip">Download</a>-->
    <!--<span class="sidebar-nav-item">Currently v1.1.0</span>-->
  </nav>

  <!--<div class="sidebar-item">-->
    <!--<p>-->
      <!--&copy; 2022. All rights reserved.-->
    <!--</p>-->
  <!--</div>-->
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Coffee and Contemplation</a>
            <small>A developer blog</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2020/12/27/what-i-learned-from-doing-dishes/">
        What I learned from doing dishes
      </a>
    </h1>

  <span class="post-date">
    27 Dec 2020 |
    
        <a class="post-tag" href="http://localhost:4000/tag/#contemplation"> contemplation </a>
    
  </span>

    I woke up today and was welcomed by a mountain of dishes in the sink. My first reaction was - "Screw that - I'll just go back to bed". So, after a couple more hours of sleep, I went back to find that the mountain hadn't magically disappeared.

Now I had to tackle this problem. This is the strategy I followed

1. Move everything out of the sink back into the kitchen.
1. Take 5 utensils into the sink.
1. Wash them.
1. If there are more dishes left, goto 2.

That was it! The mountain of dishes were done.

This is how a typical Monday looks like too. You wake up - look at the mountin of tasks - try to do them all at once - fail miserably - wonder at the end of the week, what went wrong.

All you need to do is this - split the tasks into *"5-utensil-size"* tasks. Tackling smaller tasks is easy and far, far less intimidating.

I've started doing that now, and not digitally. Grabbed a notebook and started adding tasks in there and splitting them. The inspiration for this came from the [Bullet journal method](https://bulletjournal.com/) designed by Ryder Carroll.

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2020/11/13/fuzzy-finding-in-vim/">
        Fuzzy finding in vim - vim + fzf
      </a>
    </h1>

  <span class="post-date">
    13 Nov 2020 |
    
        <a class="post-tag" href="http://localhost:4000/tag/#vim"> vim </a>
    
        <a class="post-tag" href="http://localhost:4000/tag/#neovim"> neovim </a>
    
        <a class="post-tag" href="http://localhost:4000/tag/#plugin"> plugin </a>
    
  </span>

    FZF is the center-piece of my vim configuration. It is another excellent piece of software by [Junegunn Choi](https://github.com/junegunn).
> `fzf` is a command line fuzzy finder.

Now, that doesn't sound like much. But the way it can integrate with your other tools will blow your mind. The repository for FZF is located [here](https://github.com/junegunn/fzf) and has extensive documentation on how to use it. Follow [these instructions](https://github.com/junegunn/fzf#installation) to install it.

To see how it works, run this command:
``` bash
vim $(find . | fzf)
```
`find .` will list all the files in the directory recursively. You pipe that output into `fzf`.  Fuzzy search for the file of your choice and press enter. `fzf` will output that filename and that is passed as an argument to `vim`. Pretty neat, huh? `fzf` also has a multiselect mode which can be activated with `fzf -m`. You can select multiple entries by pressing `TAB`.

`fzf` has a [plugin](https://github.com/junegunn/fzf.vim) interface for using it in vim. Before installing and jumping into it, we need to lay some groundwork.


## RipGrep
[RipGrep](https://github.com/BurntSushi/ripgrep) is a faster replacement for grep written in rust. Output of some ripgrep commands will be piped into fzf to get our desired setup.
Now, go [install ripgrep](https://github.com/BurntSushi/ripgrep#installation). The binary is called `rg`.

## Vim leader key
Vim can map a sequence of keys to an action. Leader is just another key in that sequence. For example,
`map <leader>q :q<CR>` will map the sequence `<leader>` + `q` to `:q <enter>`. The default leader key is `\`. You can change the value of leader with `:mapleader`. I find `space` to be the best key for leader. It is accessible with both fingers and it isn't really doing anything else in the normal mode. So, go ahead and add this line in your `vimrc`.

```vim
let mapleader = "\<Space>"
```

## Install fzf.vim
We saw how to install plugins using `vim-plug` in [another post](/2020/11/07/vimming-in-2020/).

Add these 2 lines to your vimrc(Between `plug#begin` and `plug#end`).
```
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
```

Now, let us setup some config and keybindings for useful commands.
```vim
" use ripgrep to search for files
let $FZF_DEFAULT_COMMAND = 'rg -l ""'

map <C-p> :Files<CR>
map <C-b> :Buffers<CR>
map <Leader><Leader> :Commands<CR>
map <Leader>/ :execute 'Rg ' . input('Rg/')<CR>
map <Leader>l :BLines<CR>
map <Leader>gf :GF?<CR>
```

This will create the following mappings

| Keybindings   | Action                                                                                     |
| :-----------  | -----------                                                                                |
| `Ctrl + p`    | Fuzzy find files in the current working directory                                          |
| `Ctrl + b`    | Fuzzy find open buffers                                                                    |
| `space space` | Fuzzy find from a list of all available commands                                           |
| `space /`     | Search for some text within the working directory. Enter the text after pressing `space /` |
| `space l`     | Fuzzy search lines in the open file                                                        |
| `space g f`   | Fuzzy search for files that got added/changed after the last commit                        |

You can find a list of commands [here](https://github.com/junegunn/fzf.vim#commands). See if anything tickles your fancy.

## Searching for word under cursor
Something that I do pretty regularly is to search for the word under my cursor. This can be done by defining a vim function. I bind it to `space G`(That is an uppercase G).
```
command! -bang -nargs=* RgExact
  \ call fzf#vim#grep(
  \   'rg -F --column --line-number --no-heading --color=always --smart-case -- '.shellescape(<q-args>), 1,
  \   fzf#vim#with_preview(), <bang>0)

nmap <Leader>G :execute 'RgExact ' . expand('<cword>') <Cr>
```

## Example
<script id="asciicast-Q6G8YUsCbTETze0P07XFwmevF" src="https://asciinema.org/a/Q6G8YUsCbTETze0P07XFwmevF.js" async></script>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2020/11/07/vimming-in-2020/">
        Vimming in 2020
      </a>
    </h1>

  <span class="post-date">
    07 Nov 2020 |
    
        <a class="post-tag" href="http://localhost:4000/tag/#vim"> vim </a>
    
        <a class="post-tag" href="http://localhost:4000/tag/#neovim"> neovim </a>
    
        <a class="post-tag" href="http://localhost:4000/tag/#plugin"> plugin </a>
    
  </span>

    > If you use vim, you can use `h,j,k,l` keys to navigate instead of the arrow keys. You won't have to move your hands away from the home row, and you'll end up saving a lot of time.

One of my seniors in college told me this about vim. It sounded so incredibly ridiculous at that time, that I decided to give it a shot.

For the first couple of years, my `.vimrc` looked like this.
```vim
set nu
set cindent
syntax on
```
This enabled line numbers, indentation and added some syntax highligting to the code.

My real journey into vim started with this post titled ["How I boosted my vim"](https://nvie.com/posts/how-i-boosted-my-vim/) by Vincent Driessen.
It introduced me to vim's plugin ecosystem and I found out there is more to vim than `h,j,k,l`.

10 years later, my [(neo)vim](https://neovim.io/) looks like this:
![neovim screenshot](/public/neovim_scrot.png "Screenshot of neovim")


## Basic setup
Depending on if you are using vim or neovim, startup file is different. For vim, it is `~/.vimrc`.
For neovim, it is `~/.config/nvim/init.vim`. Add the following block into your startup file.

```vim
filetype plugin indent on
syntax on

set modeline
set encoding=utf-8
set termencoding=utf-8
set tabstop=4                   " a tab is four spaces
set expandtab                   " Use spaces to insert a <TAB>
set backspace=indent,eol,start  " allow backspacing over everything
                                " in insert mode
set autoindent                  " always set autoindenting on
set copyindent                  " copy the previous indentation
                                " on autoindenting
set number                      " always show line numbers
set shiftwidth=4                " number of spaces to use
                                " for autoindenting
set shiftround                  " use multiple of shiftwidth when
                                " indenting with '<' and '>'
set smarttab                    " insert tabs on the start
                                " of a line according to
                                " shiftwidth, not tabstop
set hlsearch                    " highlight search terms
set incsearch                   " show search matches as you type
set ignorecase                  " ignore case when searching
set smartcase                   " ignore case if search pattern is all
                                " lowercase, case-sensitive otherwise
set scrolloff=8                 " Start scrolling at the last 8 lines
set history=1000                " remember more commands and search history
set undolevels=1000             " 1000 levels of undo
set title                       " change the terminal's title
set noerrorbells                " don't beep
set wildmenu                    " Better command line completion
set wildmode=list:longest,full
set nobackup                    " no backup files
set nowritebackup
set noswapfile                  " no swap files
set nolazyredraw
set hidden
set cmdheight=2                 " Better display for messages
set updatetime=300
set inccommand=nosplit          " Preview for search and replace
                                " (neovim only)

set pastetoggle=<F2> " F2 Toggles set paste
au InsertLeave * set nopaste " Exit paste mode when leaving insert mode

" No shift for :
nnoremap ; :

" Navigate wrapped lines easily
nnoremap j gj
nnoremap k gk

" Remove highlight on ,/
nmap <silent> ,/ :nohlsearch<CR>

" Correct typos
aug FixTypos
    :command! WQ wq
    :command! Wq wq
    :command! QA qa
    :command! Qa qa
    :command! W w
    :command! Q q
aug end
```

If you would like to know more details about any of these settings, you can do a `:h <command>`. For eg:- `:h autoindent`

## Plugins
[`vim-plug`](https://github.com/junegunn/vim-plug) by Junegunn Choi is a good candidate for a plugin manager.

Install `vim-plug`.

**For vim in osx, linux**
```
curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
```
**For neovim in osx, linux**
```
sh -c 'curl -fLo "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/autoload/plug.vim --create-dirs \
       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
```
For others, see [here](https://github.com/junegunn/vim-plug#installation). When you start vim next, the `vim-plug` will be installed.

Now, let us install a plugin called `lightline`.  The URL for `lightline` on github is [https://github.com/itchyny/lightline.vim](https://github.com/itchyny/lightline.vim). You need to use the url slug for the plugin to install it; like shown below.

```
call plug#begin('~/.vim/plugged')

Plug 'itchyny/lightline.vim'

call plug#end()
```
To install the plugin, quit vim and run `vim +PlugInstall`. When you restart vim, you can see a better status line(the line the bottom of vim).

`vim-plug` provides some [commands](https://github.com/junegunn/vim-plug#commands) to manage plugins. Here are some I use often.
1. `PlugInstall` - Installs all the listed plugins in `vimrc`.
1. `PlugUpdate` - Updates all the listed plugins in `vimrc`.
1. `PlugClean` - Removes unlisted plugins.


  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2020/10/31/python-context-manager/">
        Context managers in python
      </a>
    </h1>

  <span class="post-date">
    31 Oct 2020 |
    
        <a class="post-tag" href="http://localhost:4000/tag/#python"> python </a>
    
        <a class="post-tag" href="http://localhost:4000/tag/#functional"> functional </a>
    
  </span>

    Say, you have to open and process a file in python. You can do that using a function like this
```python
def open_and_process(filename):
    file = open(filename)
    process(file)
    file.close()  # This is important
```
If an exception occurs in the `process` function, `file.close()` won't be executed.

This pattern is the same for other types of resources too:
1. Acquire resource
2. Use resource
3. Release resource

If something fails during the **use** phase, the resource won't be released cleanly.
There are a couple of ways to solve this.
1. Use `try...finally`
```python
def open_and_process(filename):
    try:
        file = open(filename)
        process(file)
    finally:
        file.close()
```
2. Python Context Managers.

You would have seen code in python that looks like this.
```python
with open(filename) as word_file:
    words = word_file.readlines()
```

A **Context Manager** is a class which implements `__enter__` and `__exit__` functions
```python
class context:
    def __init__(self):
        print("initializing")

    def __enter__(self):
        print("entering block")
        return(10)

    def __exit__(self, _type, _value, _trace):
        print("exiting block")


with context() as val:
    print("block")
    print(val)     # This is the return value of __enter__ function

# Output
> initializing
> entering block
> block
> 10
> exiting block
```
When entering the block, the `__enter__` method is called. When exiting the block, the `__exit__` method is called. The cleanup(like closing the file) can be done in the `__exit__` method.

Luckily, python provides a [contextlib](https://docs.python.org/3/library/contextlib.html) class so that you won't have to write a class with `__enter__` and `__exit__` methods. In the example below, code before `yield` will be executed before entering the block. Code after `yield` will be executed on exiting the block.

```python
from contextlib import contextmanager

@contextmanager
def context():
    print("entering")
    try:
        yield 10
    finally:
        print("exiting")

with context() as var:
    print(var)  # this is the yielded value
    print("inside block")

# output
> entering
> 10
> inside block
> exiting
```

An interesting usecase for this is in mocking classes in tests.
Here, we are building a calculator which calls an `AdderService` to perform addition. It calls the `AdderService` using an `AdderServiceClient` class.
```python
class AdderServiceClient:
    def add(self, a, b):
        # This is an external API call. Throwing an exception to
        # indicate failure when called during tests
        raise Exception("This calls an external service "
                        "and should not be used in tests")

class Calculator():
    def __init__(self, adder):
        self.adder = adder

    def add(self, a, b):
        return self.adder.add(a, b)

def test_calculator_adds():
    calc = Calculator(AdderServiceClient())
    assert calc.add(1, 2) == 3

# This test fails with
> Exception: This calls an external service and should not be used in tests
```

Now, bring in some contextmanager magic here.
```python
from contextlib import contextmanager

@contextmanager
def mocked_adder_service_client():

    # Define a function that can add without
    # calling an external service.
    # The _ here is a placeholder for self
    def mocked_add(_, a, b):
        return a + b

    # Take a backup of the add in AdderServiceClient
    real_add = AdderServiceClient.add
    # Replace the add in AdderServiceClient with our mock function
    AdderServiceClient.add = mocked_add

    yield

    # Cleanup. Put back the real add
    AdderServiceClient.add = real_add

def test_calculator_adds():
    calc = Calculator(AdderServiceClient())
    with mocked_adder_service_client():
        assert calc.add(1, 2) == 3
```
We have a passing test case now.

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="http://localhost:4000/2020/10/23/higher-order-functions-3/">
        Higher order functions and where to find them - Decorators
      </a>
    </h1>

  <span class="post-date">
    23 Oct 2020 |
    
        <a class="post-tag" href="http://localhost:4000/tag/#python"> python </a>
    
        <a class="post-tag" href="http://localhost:4000/tag/#decorators"> decorators </a>
    
        <a class="post-tag" href="http://localhost:4000/tag/#functional"> functional </a>
    
  </span>

    We saw [what higher order functions are](/2020/10/21/higher-order-functions-1) and how they can be used in [creating partially applied functions](/2020/10/22/higher-order-functions-2) in previous posts. Now let us see how we can use higher order functions to implement python decorators.

Let us say you want to intercept your function call to log the arguments passed and the return value. ie.
```python
def add(a, b):
    return a + b

add(2, 3)
# When called with 2 and 3 as arguments, it should print
> Function add called with arguments: 2, 3
> Function add returned: 5
```
It is quite easy to do this. Let us start with defining a function `log`.
```python
def log(fun):
    def inner(*args, **kwargs):
        print(
            f"Function {fun.__name__} "
            f"called with arguments: {*args, *kwargs}")
        ret_value = fun(*args, **kwargs)
        print(f"Function {fun.__name__} returned: {ret_value}")
        return ret_value
    return inner

add_with_logging = log(add)
add_with_logging(1, 2)

# Prints the following
> Function add called with arguments: (1, 2)
> Function add returned: 3
```
But this isn't good. You are creating a new function and have to replace all usages of `add` with `add_with_logging`. There is an easy fix.
```python
# Redefine the name add to log(add)
add = log(add)
add(1, 2)
# Prints the following
> Function add called with arguments: (1, 2)
> Function add returned: 3
```
This is called a **decorator pattern** and is quite widely used in python. Python provides some [syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar) for this usage. All you need to do is add `@log` before the function definition.
```python
@log
def add(a, b):
    return a + b
add(1, 2)
# Prints the following
> Function add called with arguments: (1, 2)
> Function add returned: 3
```

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="http://localhost:4000/page3">Older</a>
  
  
    
      <a class="pagination-item newer" href="http://localhost:4000/">Newer</a>
    
  
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script src='/public/js/script.js'></script>
  </body>
</html>
